\chapter{How to build the CRTM library}
%======================================
%======================================
\label{chapter:build}

\section{Build Files}
%====================
The build system for the CRTM is relatively unsophisticated and is constructed for the Unix \f{sh} shell (or its derivative \f{bsh}, \f{bash}, or \f{ksh} shells). Currently \f{csh} (or any of its variants) is not supported.

The build system consists of a number of make, include, and configuration files in the CRTM tarball hierarchy:

\begin{tabular}{l@{ : }p{4.75in}}
  \,\texttt{makefile} & The main makefile\\
  \,\texttt{make.macros} & The include file containing the defined macros.\\
  \,\texttt{make.rules} & The include file containing the suffix rules for compiling Fortran95/2003 source code.\\
  \,\texttt{configure} & The directory containing build environment definitions.\\
\end{tabular}

\section{Predefined Configuration Files}
%=======================================
The build makefiles now assumes that environment variables (envars) will be defined that describe the compilation and link environment. The envars that \emph{must} be defined are:

\begin{tabular}{l@{ : }p{4.75in}}
  \,\texttt{FC}        & the Fortran95/2003 compiler executable,\\
  \,\texttt{FC\_FLAGS} & the flags/switches provided to the Fortran compiler,\\
  \,\texttt{FL}        & the linker used to create the executable test/example programs, and\\
  \,\texttt{FL\_FLAGS} & the flags/switches provided to the linker.\\
\end{tabular}
  
Several shell source files are provided for the build environment definitions for the compilers to which we have access and have tested here at the JCSDA. These shell source files are in the \f{configure} subdirectory of the tarball. The configuration files provided are shown in table \ref{tab:supplied_configurations}. Both ``production'' and debug configurations are supplied, with the former using compiler switches to produce fast code and the latter using compiler switches to turn on all the available debugging capabilities. Note that the debug configurations will produce executables much slower than the production builds. 
\begin{table}[htp]
  \centering
  \caption{Supplied configuration files for the CRTM library and test/example program build.}
  \begin{tabular}{p{2cm} p{3cm} r@{.}l r@{.}l}
    \hline
    \sffamily\textbf{Platform} & \sffamily\textbf{Compiler} & \multicolumn{2}{c}{\sffamily\textbf{Production}} & \multicolumn{2}{c}{\sffamily\textbf{Debug}} \\
    \hline\hline
    \multirow{4}{*}{Linux} & GNU gfortran          & \texttt{gfortran}&\texttt{setup} & \texttt{gfortran\_debug}&\texttt{setup}\\
                           & Intel ifort           & \texttt{intel}&\texttt{setup}    & \texttt{intel\_debug}&\texttt{setup}   \\
                           & PGI pgf95             & \texttt{pgi}&\texttt{setup}      & \texttt{pgi\_debug}&\texttt{setup}     \\
                           & g95                   & \texttt{g95}&\texttt{setup}      & \texttt{g95\_debug}&\texttt{setup}     \\[0.3cm]
    IBM                    & AIX xlf95             & \texttt{xlf}&\texttt{setup}      & \texttt{xlf\_debug}&\texttt{setup}     \\
  \hline
  \end{tabular}
  \label{tab:supplied_configurations}
\end{table}


\section{Compilation Environment Setup}
%======================================
To set the compilation envars for your CRTM build, you need to source the required configuration setup file. For example, to use \f{gfortran} to build the CRTM you would type

\begin{verbatim}     . configure/gfortran.setup\end{verbatim}

in the main directory. Note the ``.'' and space preceding the filename. This should print out something like the following:
\begin{alltt}
  =========================================
   CRTM compilation environment variables:
     FC:       gfortran
     FC_FLAGS:  -c  -O3  -fimplicit-none  -fconvert=big-endian  -ffree-form
                -fno-second-underscore  -frecord-marker=4  -funroll-loops
                -ggdb  -Wall  -std=f2003  
     FL:       gfortran
     FL_FLAGS:  
     FL_FLAGS: 
  =========================================\end{alltt}

indicating the values to which the envars have been set.

Change the supplied setups to suit your needs. If you use a different compiler please consider submitting your compilation setup to be included in future releases.

Note that as of CRTM v2.0, the Fortran compiler needs to be compatible with the ISO TR-15581 Allocatable Enhancements update to Fortran95. Most current Fortran95 compilers do support TR-15581.


\section{Building the library}
%=============================
Once the compilation environment has been set, the CRTM library build is performed by simply typing,

\begin{verbatim}     make\end{verbatim}
   
after which you should see the source file compilation output. Depending on the compiler used you may see various warning messages, for example

\f{  warning: 'cchar[1]{lb: 1 sz: 1}' may be used uninitialized in this function}

or

\f{  PGF90-I-0035-Predefined intrinsic scale loses intrinsic property}

etc. The actual format of the warning message depends on the compiler. We are working on eliminating these warning messages where appropriate or necessary. 

Note that the current build process is set up to generate a static library not a shared one.


\section{Testing the library}
%============================
Several test/example programs exercising the forward and K-matrix functions have been supplied with the CRTM. To build and run all these tests, type,

\begin{verbatim}     make test\end{verbatim}
   
This process does generate a lot of output to screen so be prepared to scroll through it. Currently there are ten forward model test, or example, programs:
\begin{alltt}
  test/forward/Example1_Simple
  test/forward/Example2_SSU
  test/forward/Example3_Zeeman
  test/forward/Example4_ODPS
  test/forward/Example5_ClearSky
  test/forward/Example6_ChannelSubset
  test/forward/Example7_AOD
  test/forward/Example9_Aircraft
  test/forward/Example10_ScatteringSwitch
  test/forward/Example11_SOI\end{alltt}
And there are nine cases for the K-matrix model:
\begin{alltt}
  test/k_matrix/Example1_Simple
  test/k_matrix/Example2_SSU
  test/k_matrix/Example3_Zeeman
  test/k_matrix/Example4_ODPS
  test/k_matrix/Example5_ClearSky
  test/k_matrix/Example6_ChannelSubset
  test/k_matrix/Example7_AOD
  test/k_matrix/Example10_ScatteringSwitch
  test/k_matrix/Example11_SOI\end{alltt}

Both the forward and K-matrix tests \emph{should} end with output that looks like:

\begin{alltt}
  ======================
  SUMMARY OF ALL RESULTS
  ======================

  Passed 42 of 42 tests.
  Failed 0 of 42 tests.\end{alltt}

Currently they both have the same number of tests. If you encounter failures you might see something like:

\begin{alltt}
  ======================
  SUMMARY OF ALL RESULTS
  ======================

  Passed 32 of 42 tests.
  Failed 10 of 42 tests.  <----<<<  **WARNING**\end{alltt}

Some important things to note about the tests:
\begin{itemize}
  \item The supplied results were generated using the \f{gfortran} DEBUG build.
  \item Comparisons between DEBUG and PRODUCTION builds can be different due to various compiler switches that modify floating point arithmetic (e.g. optimisation levels), or different hardware.
  \item For test failures, you can view the differences between the generated and supplied ASCII output files. For example, to view the K-matrix \f{Example1\_Simple} test case differences for the \f{amsua\_metop-a} sensor you would do something like:
\begin{alltt}
  $ cd test/k_matrix/Example1_Simple
  $ diff -u amsua_metop-a.output results/amsua_metop-a.output | more\end{alltt}

where the \f{amsua\_metop-a.output} file is generated during the test run, and the \f{results/amsua\_metop-a.output} file is supplied with the CRTM tarball.
  \item The differences that typically result are quite small (of the order of microKelvin or less when there is a noticable difference in the computed brightness temperatures), although not always at the numerical precision limit.
  \item A graphical differencing tool such as \href{http://tkdiff.sourceforge.net/}{tkdiff}, \href{http://meldmerge.org/}{meld}, or FileMerge/opendiff (on Mac OSX) is recommended for viewing the dile differences.
\end{itemize}


\section{Installing the library}
%===============================
A very simple install target is specified in the supplied makefile to put all the necessary include files (the generated \texttt{*.mod} files containing all the procedure interface information) in an \texttt{/include} subdirectory and the library itself (the generated \texttt{libCRTM.a} file) in a \texttt{/lib} subdirectory. The make command is
\begin{verbatim}     make install\end{verbatim}
The \texttt{/include} and \texttt{/lib} subdirectories can then be copied/moved/linked to a more suitable location on your system, for example: \texttt{\$HOME/local/CRTM}

NOTE: Currently, running the tests also invokes this install target. That will change in future tarball releases so do not rely on the behaviour.


\section{Clean Up}
%=================
Two cleanup targets are provided in the makefile:

\begin{verbatim}     make clean\end{verbatim}
  
Removes all the compilation and link products from the \f{libsrc/} directory.

\begin{verbatim}     make distclean\end{verbatim} 
  
This does the same as the ``clean'' target but also deletes the library and include directories created by the ``install'' target.


\section{Linking to the library}
%===============================
Let's assume you've built the CRTM library and placed the \texttt{/include} and \texttt{/lib} subdirectories in your own local area, \texttt{\$HOME/local/CRTM}. In the makefile for your application that uses the CRTM, you will need to add
\begin{verbatim}     -I$HOME/local/CRTM/include\end{verbatim}
to your list of compilation switches, and the following to your list of link switches,
\begin{verbatim}     -L$HOME/local/CRTM/lib -lCRTM\end{verbatim}
